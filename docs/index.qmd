---
title: "**Extendable** projection of social contact matrices"
subtitle: "University of Canterbury"
date: "21-09-2022"
author: "Nicholas Tierney"
institute: Telethon Kids Institute
format: 
  revealjs:
    theme: [blood, extra.scss]
    incremental: true
    slide-number: true
    show-slide-number: all
    footer: "njtierney.github.io/talk-canterbury-2022/"
editor: visual
execute: 
  echo: false
  warning: false
  cache: true
  freeze: true
---

```{r}
#| label: library
#| include: false
library(tidyverse)
library(knitr)
library(conmat)
library(colorspace)
library(naniar)
library(visdat)
library(brolgar)
library(icons)
```

```{r}
#| label: source-r-files
#| echo: false
#| message: false
#| output: false
lapply(list.files(here::here("R"), full.names = TRUE), source)
```

```{r}
#| label: helpers
#| include: false

icons_fa <- icons::fontawesome
icon_box <- icon_style(icons_fa$solid$`box-open`, fill = "#f0a800")
icon_link <- icon_style(icons_fa$solid$link, fill = "#f0a800")
icon_twitter <- icon_style(icons_fa$brands$twitter, fill = "#f0a800")
icon_github <- icon_style(icons_fa$brands$github, fill = "#f0a800")
icon_plane <- icon_style(icons_fa$solid$`paper-plane`, fill = "#f0a800")


as_table <- function(...) knitr::kable(..., format='html', digits = 3)

theme_set(
  theme_grey(base_size = 16) +
  theme(
    legend.position = "bottom",
    plot.background = element_rect(fill = "transparent"),
    legend.background = element_rect(fill = "transparent")
  )
)

# **ni**ck's **pa**lette
nipa <- list(red = "#c03018",
             orange = "#f0a800",
             green = "#609048",
             purple = "#484878",
             light_purple = "#A3A3BB",
             light_green = "#AFC7A3",
             light_orange = "#F7D37F",
             light_red = "#DF978B",
             pale_purple = "#ECECF1",
             pale_green = "#D7E3D1",
             pale_orange = "#FBE9BF",
             pale_red = "#EFCBC4")

```

## What this talk is about

-   Explain **how** I came to help write software for infectious disease modelling

-   Touch on the **overall** approach for methods (not enough time). The majority of my role was on software and interface design.

-   Instead, I'll discuss **why** we needed our own method & software design decisions

-   Advocate for contributions of **software design + statistical thinking**: *the way of the research software engineer*, so to speak.


## The story so far

-   2008-2012: Undergraduate + honours in Psychology

-   2013 - 2017: PhD Statistics, QUT

    -   Exploratory Data Analysis (EDA)
    -   Bayesian / Geospatial statistics / Optimal placement

-   2018 - 2020: Research Fellow / Lecturer at Monash

    -   Design and improve tools for EDA

-   2020 - 2022: Research Software Engineer \@ Telethon Kids Institute

    -   Maintain and design tools for data analysis

::: notes
\- Climbed Mt Kilimanjaro

\- Hiked The Overland, Larapinta Trail, 1/3 of Australian Alpine Walking Track, The Cape to Cape

\- Carve spoons (from wood)

\- Enjoy running long distances on trails (80K, 50K, 55K, preparing for a 168K race)
:::

## `visdat::vis_dat(airquality)`

```{r}
#| label: show-visdat
#| fig-height: 3.5
#| fig-width: 8
vis_dat(airquality)
```

## `naniar::gg_miss_upset(airquality)`

```{r}
#| label: gg-miss-upset
#| fig-height: 3.5
#| fig-width: 8
gg_miss_upset(airquality)
```

## `brolgar` - take spaghetti

```{r}
#| label: gg-brolgar
ggplot(heights,
       aes(x = year,
           y = height_cm,
           group = country)) + 
  geom_line()
```

## `brolgar` - spread spaghetti

```{r}
#| label: gg-brolgar-spread
ggplot(heights,
       aes(x = year,
           y = height_cm,
           group = country)) + 
  geom_line() + 
  facet_strata(along = -year)
```

::: notes
I'm a research software engineer, I help translate research methods into open source research software. One of my primary tasks is Extending/maintaining `greta` for statistical computing. I also work on creating and extending other software as needed for our team. Optional bits: PhD statistics - emphasis on frustration developing workflows R packages to facilitate exploratory data analysis Overviews, missing data, longitudinal data
:::

##  {background-image="images/greta-logo-background.png" background-size="contain"}



<!-- Professor Nick Golding -->

<!-- [greta-stats.org](https://www.greta-stats.org) -->

## greta is R code

:::: {.columns}

::: {.column width="45%"}

**stan**
```
data {
  real alpha;
  real beta;
  real<lower=0> sigma2;
  int<lower=0> J;
  array[J] int y;
  vector[J] Z;
  array[J] int n;
}
transformed data {
  real<lower=0> sigma;
  sigma = sqrt(sigma2);
}
parameters {
  real theta1;
  real theta2;
  vector[J] X;
}
model {
  array[J] real p;
  theta1 ~ normal(0, 32); // 32^2 = 1024 
  theta2 ~ normal(0, 32);
  X ~ normal(alpha + beta * Z, sigma);
  y ~ binomial_logit(n, theta1 + theta2 * X);
}
```
:::

::: {.column width="55%"}

**JAGS**

```
for(j in 1 : J) {
   y[j] ~ dbin(p[j], n[j])
   logit(p[j]) <- theta[1] + theta[2] * X[j]
   X[j] ~ dnorm(mu[j], tau)
   mu[j] <- alpha + beta * Z[j]
}
theta[1] ~ dnorm(0.0, 0.001)
theta[2] ~ dnorm(0.0, 0.001)
```

**greta**

```r
theta <- normal(0, 32, dim = 2)
mu <- alpha + beta * Z
X <- normal(mu, sigma)
p <- ilogit(theta[1] + theta[2] * X)
distribution(y) <- binomial(n, p)
```

:::

::::

# google tensorflow

:::: {.columns}

::: {.column width="45%"}

- automatic differentiation
- efficient linear algebra
- highly parallel

:::

::: {.column width="45%"}

```{r}
#| label: tf-examples
include_graphics("images/tf-examples.png")
```

:::

::::

## extendable

```{r}
#| label: extendable
include_graphics("images/greta-extendable.png")
```

# `greta.gp`


> `greta.gp` extends `greta` to let you define Gaussian processes as part of your model. It provides a syntax to create and combine GP kernels, and use them to define either full rank or sparse Gaussian processes.

:::: {.columns}

::: {.column width="60%"}

```r
# kernel & GP
kernel <- rbf(rbf_len, rbf_var) + 
            bias(1)
f <- gp(x, kernel)
# likelihood
distribution(y) <- normal(f, obs_sd)
# prediction
f_plot <- project(f, x_plot)
```

:::

::: {.column width="38%"}

```{r extendable-greta-gp}
include_graphics("images/greta-extendable-gp.png")
```

:::

::::

## Define: Research Software Engineer

> A Research Software Engineer (RSE) combines professional software engineering expertise with an intimate understanding of research.

-- (from https://society-rse.org/about/)

## What sorts of things does an RSE do?

- Create software to **solve research problems**
- Develop tools that **abstract the right components** to facilitate research
- Help researchers to **find and learn** good tools
- Support researchers with (computational) reproducibility


- (adapted from Heidi Seibold's [UseR2021 Keynote talk](https://docs.google.com/presentation/d/1XQc2U2X8hiK43UzUi9IwvsvULxhVy0WzWSa_Kt4ZJv4/view#slide=id.gdbfb32d486_0_448))


::: notes
I bring this up because I feel a bit of a need to explain my background to help explain the context of what I do
:::


## Joining an infectious disease team

- August, 2021: Australia is working on the plan to reopen, part of "The Doherty Report"

- They need more hands to help with data analysis and software development

- I joined to assist for ~4 months

- Helped develop pipelines + software for disease modelling, establish code base for people to contribute

# Soliloquy

::: notes
I wanted to take a moment to talk about the dedication of this group of people. They worked tirelessly, and had been working tirelessly since March 2020. There were a heap of tight deadlines, and massive amounts of work that they graciously took on. It was a massive honour to work with all of these people.
:::

## Infectious Disease Modelling



-   Diseases like COVID19 and Influenza spread through face to face social contact

::: notes
-   I think we're all familiar enough with COVID to know what I mean here.
:::

-   Describe which 3 people had contact:

    -   James has had contact with Luke

    -   Nick hasn't had contact with either

::: notes
So say we have 3 people and we want to describe who have had face to face contact in the past week. Let's take myself and my two brothers. They're both in Brisbane and I'm not, so I haven't seen them. We might say:
:::

## Example: visually

```{r}
name_vec <- c("James", "Luke", "Nick")
df_contact <- expand_grid(
  name_from = name_vec,
  name_to = name_vec
) %>% 
  mutate(
    contact = as.logical(c(NA, 1, 0,
                           1, NA, 0,
                           0, 0, NA)),
    contact_num = c(NA, 6, 0,
                    6, NA, 0,
                    0, 0, NA),
    contact_num_age = c(10, 6, 0,
                        6, 10, 0,
                        0, 0, 10),
    )

ggplot(df_contact,
       aes(x = name_from,
           y = name_to,
           fill = contact)) + 
  geom_tile(colour = "black") +
  scale_fill_manual(values = c("grey85", "grey20"),
                    na.value = "white") +
  theme_minimal(base_size = 18) +
  theme(aspect.ratio = 1,
        legend.position = "top")
```

::: notes
This shows whether people had contact, yes or no. We can see that everyone had contact with one another except for Nick, and with Nick. Note that we could change this from something logical - "did they have contact" to "how many times did you have contact?"
:::

## Example: matrix

```{r}
#| label: example-matrix
#| attr-output: 'style="font-size:170%;"'

df_mat <- df_contact %>% 
  select(-contact_num,
         -contact_num_age) %>% 
  pivot_wider(
    names_from = name_from,
    values_from = contact
  ) %>% 
  select(-name_to) %>% 
  as.matrix()

colnames(df_mat) <- unique(df_contact$name_from)
rownames(df_mat) <- unique(df_contact$name_from)
df_mat

```

## Logical --\> Numeric

```{r}
ggplot(df_contact,
       aes(x = name_from,
           y = name_to,
           fill = contact_num)) + 
  geom_tile(colour = "black") +
  scale_fill_continuous_sequential(palette = "Purples 2",
                                   na.value = "black") +
  theme_minimal(base_size = 18) +
  labs(fill = "# Contacts") + 
  theme(aspect.ratio = 1)
```

::: notes
So now we have not just, "Did you have contact?", but, "How many times did you have contact?" Instead of individual people, we could change this to age groups.
:::

## People --\> Age groups

```{r}
#| echo: false
df_contact_ages <- df_contact %>% 
  mutate(
    across(
      .cols = c(name_from, name_to),
      .fns = ~case_when(
        .x == "James" ~ "0-9",
        .x == "Luke" ~ "10-19",
        .x == "Nick" ~ "20-29",
      )
    )
  ) %>% 
  rename(
    age_from = name_from,
    age_to = name_to
  )

ggplot(df_contact_ages,
       aes(x = age_from,
           y = age_to,
           fill = contact_num_age)) + 
  geom_tile(colour = "black") +
  scale_fill_continuous_sequential(palette = "Greens 2") +
  theme_minimal(base_size = 18) +
  labs(fill = "# Contacts") + 
  theme(aspect.ratio = 1)
```

## What do you do with this?

-   If we know how many times people have contact, we have an idea of which age groups will spread COVID

-   Simulate how many COVID cases would get transmitted

-   Explore how vaccination reduces transmission

-   Do this for different areas in Australia

## Do we know how much contact people have?

-   We don't. Well, not in Australia. Yet.

-   You need to conduct a surveys where people diary the amount and manner of daily contacts they have.

-   [Mossong et al](https://journals.plos.org/plosmedicine/article?id=10.1371/journal.pmed.0050074) have this for 8 countries in Europe

- Referred to as the POLYMOD study

::: notes
-   So we have a pretty good idea of the amount of contact people have in Europe.
:::

## Method of Mossong et al

-   Random weekday: record every person in contact with.
-   Physical contact:
    -   skin-to-skin contact (kiss or handshake)
-   Non-physical contact:
    -   two-way conversation with 3+ words in physical presence of a person

## Method of Mossong et al

-   Participants provide info on:
    -   age and sex of each contact person
    -   location (home, work, school, etc)
    -   time spent together
    -   frequency of usual contacts with this individual

## Contact surveys are 💰 💰 💰

-   Part of why we don't have them in Australia
-   Can we get a contact matrix for a country not on the list?
-   We need to have a best guess from existing surveys

## Synthetic contact matrices

-   Pre-existing statistical methodologies project empirical contact matrices to new countries.
-   New projected contact matrices: "synthetic contact matrices"
-   Use existing contact surveys (e.g., Mossong)
-   Use setting-specific survey data on household, school, classroom, and workplace composition
-   Combine with empirical data on contact patterns in Europe using statistical models

## Prem et al

-   Prem et al. have one of the most widely used approaches to synthetic contact matrices
-   Extensively applied across infectious diseases applications
-   Initially provided 155 matrices for 155 countries (177 later in 2020)


## Brief explainer of Prem

-   $X^{L}_{i,\alpha} \sim Poisson(\mu_{i, \alpha}^{L})$

-   $X^{L}_{i,\alpha}$ is the number of contacts made by individual $i$ at a particular location $L$ with someone in age group $\alpha$ is modelled to be Poisson with mean $\mu_{i}^{L}$.

-   the ages of individual $i$, $\alpha_i$, and their contact, $\alpha$ are broken into 5 year age intervals

-   $L$ denotes contact location: L = ... H (Home), W (Work), S (School), O (other)

- Main thrust: Contact matrices are projected because the age distribution of population is included in $\mu$

## Brief explainer of Prem

-   Core ideas:

    -   Build a model from the POLYMOD study, predicting number of contacts
    -   Incorporate key age information for different locations (home, work, school, other)
    -   Extrapolate the number of contacts to different countries, using age information from those countries
    -   Create a new contact matrix for a given country

##  {background-image="images/prem-dir-mats.png" background-size="contain"}

##  {background-image="images/prem-spreadsheet.png" background-size="contain"}

::: notes
**image of spreadsheet booklet of contact matrices**

The main issue with this is that we don't have much control over the outputs.

And maybe that doesn't matter to you if you just need to look at the contact matrices for a given country.

But what we needed to do is get contact matrices for a given age population structure.
:::

## Populations are different

```{r}
melb_syd <- combine_abs_two_age_distributions(
  lga_1 = "Melbourne (C)",
  lga_2 = "Sydney (C)"
)

plot_two_abs_distributions(melb_syd)
```

## Populations are different

```{r}
alice_syd <- combine_abs_two_age_distributions(
  lga_1 = "Alice Springs (T)",
  lga_2 = "Sydney (C)"
)

plot_two_abs_distributions(alice_syd)
```

## What we want

- We want to be able use a **population age distribution** 

```{r}
#| label: fairfield
#| echo: true
fairfield <- abs_age_lga("Fairfield (C)")
fairfield
```


## What we want

- Input **population age distribution** and get out a contact matrix.

```{r}
#| eval: false
#| echo: true

extrapolate_from_data(
  population = fairfield
)
```

## How do we extend this method?

- [Code is provided](https://github.com/kieshaprem/synthetic-contact-matrices), but a few key issues:

  - It was code not written for reuse (code vs software)

    - No clear interface on how to get inputs for a given country or region.

    - Challenging to see which bits of code matched which methods

- Australia was in original 155 countries, not in the new updated 177!


## Building our own extension

- Nick Golding wrote a new method that was able to be more flexible, using GAMs instead of Bayesian approach.

- I was tasked with writing software from initial model fitting code, with guidance from Nick

- Named the package, `conmat`, ([repo](https://github.com/njtierney/conmat)), creating a home for code for others to contribute to.

- In R package form, this made it easier for us to develop and extend software on demand for our needs

## Demonstration of conmat

```{r}
#| echo: true
#| label: get-fairfield
library(conmat)
fairfield <- abs_age_lga("Fairfield (C)")
fairfield
```

## Extrapolate to a new population

```{r}
#| label: extrapolate-fairfield
#| echo: true
synthetic_fairfield <- extrapolate_polymod(
 population = fairfield,
 age_breaks = c(seq(0, 75, by = 5), Inf) # default
)
synthetic_fairfield
```

## Contact matrix: Fairfield

```{r}
#| label: plot-matrix-fairfield
#| echo: true
plot_matrix(synthetic_fairfield$home)
```

```{r}
#| message: false
#| warning: false
oz_pop <- abs_pop_age_lga_2020 %>%
    select(
      state,
      age_group,
      year,
      population
    ) %>%
    mutate(age_group = readr::parse_number(as.character(age_group))) %>%
    rename(lower.age.limit = age_group) %>%
    group_by(year, lower.age.limit) %>%
    summarise(population = sum(population)) %>% 
  ungroup()
```


```{r}
#| label: polymod-extrapolate
synthetic_polymod_oz <- extrapolate_polymod(
 population = oz_pop
)
```

## Contact matrix: Australia

```{r}
#| label: plot-matrix-polymod
#| echo: true
plot_matrix(synthetic_polymod_oz$home)
```

# How the model works



## Create A Next Generation Matrix

* Once infected, a person can transmit an infectious disease to another, creating **generations** of infected individuals. 
* We can define a matrix describing the **number of newly infected** individuals in given categories, such as age, for consecutive generations. 
* This matrix is called a **next generation matrix** (NGM).

## Create A Next Generation Matrix

```{r}
#| label: generate-ngm-fairfield
#| echo: true
ngm_fairfield <- generate_ngm(
  lga_name = "Fairfield (C)",
  age_breaks = c(seq(0, 80, by = 5), Inf),
  R_target = 1.5
)
ngm_fairfield
```

## Apply Vaccination

* Applies the effect of vaccination on the next generation of infections, to understand and describe the reduction of acquisition and transmission in each age group.

* Takes the following arguments:
  - `ngm` - a Next Generation Matrix
  - `data` - A data frame with location specifics
  - which columns are related to "coverage", "acquisition", and "transmission" in the `data` col
  
## Example vaccination data
  
```{r}
#| label: vaccination-example-data
#| echo: true
vaccination_effect_example_data
```


::: notes

I think they are the average vaccine efficacy (expressed as 1 minus the relative risk) over all vaccinated individuals in the population. I.e. we calculate an average form the number of people in that age group that have 1 dose, 2 doses, which brand, how long ago, etc.

::: 

## Apply vaccination

```{r}
#| label: apply-vaccination-fairfield
#| echo: true
ngm_vacc_fairfield <- apply_vaccination(
  ngm = ngm_fairfield,
  data = vaccination_effect_example_data,
  coverage_col = coverage,
  acquisition_col = acquisition,
  transmission_col = transmission
)

ngm_vacc_fairfield
```

## Challenges in Design

- Model fitting is fixed and rigid
  - Although there are arguments for `age_break`
- Design decision to provide access to fitting the model
- Tradeoff: **easy to use** vs **more complex to create**

```{r}
#| eval: false
#| echo: true
synthetic_fairfield <- extrapolate_polymod(
 population = fairfield,
 age_breaks = c(seq(0, 75, by = 5), Inf)
)
```


## Challenges in Design

- Hard coding variables
  - age and population columns are currently required to be named `lower.age.limit` and `population`
  - At least 2 potential ways to resolve this

```{r}
#| echo: true
fairfield
```

## Challenges in Design
    
  1.  Provide arguments for specifying the age and population information (`age_col` and `population_col`)
  
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "3-4"
extrapolate_polymod(
 population = fairfield,
 age_col = lower.age.limit,
 population_col = population
)
```
  
## Challenges in Design
  
  2.  Some kind of class based approach, where we encode or validate the `age` and `population` columns.
  
```{r}
#| eval: false
#| echo: true
#| code-line-numbers: "3-4|7"
fairfield_pop <- new_population(
  data = fairfield,
  age = lower.age.limit,
  population = population
)
extrapolate_polymod(
 population = fairfield_pop
)
```
  
## Challenges in Design: Australian-Centric

- state name / LGA name fixed
- A feature of doing things for a specific purpose and not thinking generally

```{r}
#| label: example-ngm
#| eval: false
#| echo: true
#| code-line-numbers: "2"
ngm_fairfield <- generate_ngm(
  lga_name = "Fairfield (C)",
  age_breaks = c(seq(0, 80, by = 5), Inf),
  R_target = 1.5
)
```

## Challenges in Design: Australian-Centric

- Change of interface means breaking existing code
- Can get around this with versioning and releases, or two functions

:::: {.columns}

::: {.column width="45%"}

```{r}
#| label: example-ngm-2
#| eval: false
#| echo: true
#| code-line-numbers: "1-2"
generate_ngm_oz(
  lga_name = "Fairfield (C)",
  R_target = 1.5
)
```

:::

::: {.column width="45%"}

```{r}
#| label: example-ngm-3
#| eval: false
#| echo: true
#| code-line-numbers: "1-2"
generate_ngm(
  population = fairfield,
  R_target = 1.5
)
```


:::

::::
  
## Challenges in Design

- Rigid model design means easy to use, at cost of flexibility
- Specified variable names is fragile, but saves typing
- Extra functions could always be added to be more flexible variants

## Future Directions

-   Interface to changing GAM model terms or specify model
-   Validating against Prem and other methods
-   Allowing more flexible uses of other data sources (Separate out the Australian focus)
-   Better automatic plotting (use of `autoplot`)


## Comment: Software vs code

- Initial code was given as a [gist on github](https://gist.github.com/goldingn/85d2b7363d2da2888254bb6042144150)
- Turning the code into a package was greatly facilitated with [sinew](https://github.com/yonicd/sinew) ([sinew code](https://github.com/njtierney/conmat/commit/48656e98b81273b90ec5c26eeec87eebd5f159ce#diff-46b25c6f5c66616a55c46eb2d3e236d1e4acc4e5b33f3dc934cabf7d1d396daa))
- [Github Issues are very useful](https://github.com/njtierney/conmat/issues?q=is%3Aissue+is%3Aclosed)
- Extra contributions can be implemented as [pull requests](https://github.com/njtierney/conmat/pulls?page=2&q=is%3Apr+is%3Aclosed) which can be tested with GH actions

## Comment: Workflows

- Also worked on a workflow for determining the impact of ["Test, Trace, Isolate, Quarantine" (TTIQ)](https://github.com/njtierney/ttiq-simulation)
- Used [targets](https://books.ropensci.org/targets/) R package to manage workflow - [file](https://github.com/njtierney/ttiq-simulation/blob/master/_targets.R)
- Allowed for many people to contribute to same code base (although a learning curve)
- [Used tests, very useful for plots](https://github.com/njtierney/ttiq-simulation/tree/master/tests/testthat) with [vdiffr](https://vdiffr.r-lib.org/) (**example**)
- [Issues](https://github.com/njtierney/ttiq-simulation/issues?q=is%3Aissue+is%3Aclosed) helped facilitate task delivery/discussion
- [Pull requests helped isolate issues](https://github.com/njtierney/ttiq-simulation/pulls)

# Thanks

-   Nick Golding
-   Aarathy Babu
-   Michael Lydeamore

# Learning more

`r icon_box` [github.com/njtierney/conmat](https://github.com/njtierney/conmat)

`r icon_link` [njtierney.github.io/talk-canterbury-2022](njtierney.github.io/talk-canterbury-2022)

`r icon_twitter` nj_tierney

`r icon_github` njtierney

`r icon_plane` nicholas.tierney\@gmail.com

# **End.**

# Extras

## How does the model work?

```r
fit_single_contact_model <- function(contact_data, population) {

  # programatically add the offset term to the formula, so the model defines
  # information about the setting, without us having to pass it through to the
  # prediction data
  formula_no_offset <- contacts ~
    # deviation of contact age distribution from population age distribution
    s(age_to) +
    # number of contacts by age
    s(age_from) +
    # intergenerational contact patterns - enables the off-diagonals
    s(abs(age_from - age_to)) +
    # interaction between intergenerational patterns and age_from, to remove
    # ridge for some ages and settings
    s(abs(age_from - age_to), age_from) +
    # probabilities of both attending (any) school/work
    school_probability +
    work_probability
  
  # choose the offset variable based on the setting
  setting <- contact_data$setting[1]
  offset_variable <- switch(
    setting,
    school = "log_contactable_population_school",
    "log_contactable_population"
  )
  
  # add multiplicative offset for population contactable, to enable
  # extrapolation to new demographies
  # in mgcv, this part of the offset gets used in prediction, which 
  # is what we want. Those are the "contactable" parts, which we use
  # to extrapolate to new demographics.
  formula_offset <- sprintf("~. + offset(%s)", offset_variable)
  formula <- update(formula_no_offset, formula_offset)
  
  # contact model for all locations together
  contact_data %>%
    add_modelling_features() %>%
      # The modelling features added here are:
        # the school and work offsets
        # pop_age_to (interpolated population)
        # `log_contactable_population_school`, and ` log_contactable_population`
      population = population
    mgcv::bam(
      formula = formula,
      family = stats::poisson,
      # add number of participants as a multilpicative offset here rather than in
      # the formula, so it is not needed for prediction,
      # NOTE: the offset of participants allows us to get the rate per person
      offset = log(participants),
      data = .
    )
  
}
```

## Alt approach to conmat model

```{r}
#| label: show-fairfield
#| echo: true
# fit a model
library(conmat)
fairfield_age_pop <- abs_age_lga("Fairfield (C)")
fairfield_age_pop

```

## Alt approach to conmat model

```{r}
#| label: alt-fit
#| echo: true
polymod_contact_data <- get_polymod_setting_data()
polymod_survey_data <- get_polymod_population()

```

## Alt approach to conmat model

```{r}
#| label: alt-fit-2
#| echo: true
setting_models <- fit_setting_contacts(
  contact_data_list = polymod_contact_data,
  population = polymod_survey_data
  )

str(setting_models)
```

## Alt approach to conmat model

```{r}
#| label: alt-fit-3
#| echo: true
synthetic_settings_5y_fairfield <- predict_setting_contacts(
  population = fairfield_age_pop,
  contact_model = setting_models,
  age_breaks = c(seq(0, 85, by = 5), Inf)
  )

synthetic_settings_5y_fairfield
```

# **This is the last slide.**
